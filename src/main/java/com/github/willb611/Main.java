package com.github.willb611;

import com.github.willb611.rabbitmq.MyConsumer;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.MessageProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

public class Main {
  private static final String QUEUE_NAME = "foo.bar";
  private static final int FIVE_SECONDS_IN_MILLIS = 5000;
  private Logger logger = LoggerFactory.getLogger(Main.class);
  private int MESSAGE_COUNT = 5000;


  public static void main(String[] args) {
    new Main().sendOrReceiveFromRabbitMQ();
  }

  public void sendOrReceiveFromRabbitMQ() {
    ConnectionFactory connectionFactory = new ConnectionFactory();
    connectionFactory.setHost("localhost");
    // From an exception log line, I think default URI is something like: AMQChannel(amqp://guest@127.0.0.1:5672/,1)

    try (Connection connection = connectionFactory.newConnection()) {
      logger.info("[sendOrReceiveFromRabbitMQ] Created connection, address: {} at port {}",
          connection.getAddress(), connection.getPort());
      Channel channel = connection.createChannel();

      // Durable channel means durable messages on the queue are saved if RabbitMQ quits or crashes
      channel.queueDeclare(QUEUE_NAME, true,
          false, false, null);

      //sendMessages(channel);
      readMessages(channel);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private void sendMessages(Channel channel) throws IOException {
    for (int messageSentSoFar = 0; messageSentSoFar < MESSAGE_COUNT; messageSentSoFar++) {
      String message = "Hello world, #" + messageSentSoFar;
      // Publish with properties PERSISTENT_TEXT_PLAIN to make message durable.
      // So message is saved if RabbitMQ quits or crashes (after message has been persisted to disk)
      channel.basicPublish("", QUEUE_NAME,
          MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());

      logger.info("[sendMessages] Sent {} to {}", message, QUEUE_NAME);
    }
  }

  private void readMessages(Channel channel) throws IOException {
    String consumerTag = channel.basicConsume(QUEUE_NAME, new MyConsumer(channel));
    logger.info("[readMessages] consumerTag generated by the server for my consumer: {}", consumerTag);

    while (channel.messageCount(QUEUE_NAME) > 0) {
      logger.info("[readMessages] Waiting until messages have all been read from the queue, sleeping..");
      try {
        Thread.sleep(FIVE_SECONDS_IN_MILLIS);
      } catch (InterruptedException e) {
        logger.error("[ReadMessages] Unexpected interrupt while consuming messages", e);
      }
    }
  }
}
